/*
 * Copyright (c) 2017 OCLC, Inc.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the MIT/X11 license. The text of the license can be
 * found at http://www.opensource.org/licenses/mit-license.php.
 */

package org.oclc.circill.toolkit.binding.jaxb;

import static org.oclc.circill.toolkit.service.base.ToolkitHelper.toByteArray;

import org.oclc.circill.toolkit.common.base.LoggingHelper;
import org.oclc.circill.toolkit.common.base.MessageCache;
import org.oclc.circill.toolkit.common.base.StatisticsBean;
import org.oclc.circill.toolkit.common.base.Translator;
import org.oclc.circill.toolkit.service.base.ConfigurationException;
import org.oclc.circill.toolkit.service.base.ProtocolHelper;
import org.oclc.circill.toolkit.service.base.ServiceContext;
import org.oclc.circill.toolkit.service.base.ServiceException;
import org.oclc.circill.toolkit.service.base.ServiceInitiationData;
import org.oclc.circill.toolkit.service.base.ServiceMessage;
import org.oclc.circill.toolkit.service.base.ServiceResponseData;
import org.oclc.circill.toolkit.service.base.ToolkitException;
import org.oclc.circill.toolkit.service.base.ToolkitInternalException;
import org.oclc.circill.toolkit.service.base.ValidationException;
import org.oclc.circill.toolkit.service.base.XMLServiceContext;

import javax.xml.XMLConstants;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.UnmarshallerHandler;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.transform.sax.SAXSource;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Map;

import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;

/**
 * Base class for {@link Translator} implementations that use JAXB to marshall and unmarshall messages.
 * @param <SM> the {@link ServiceMessage} type
 * @param <ID> the {@link ServiceInitiationData} type
 * @param <RD> the {@link ServiceResponseData} type
 * @param <JAXBM> the type of Object generated by JAXB to represent messages
 */
public abstract class BaseJAXBTranslator<SM extends ServiceMessage<ID, RD>, ID extends ServiceInitiationData, RD extends ServiceResponseData, JAXBM extends Object>
    implements Translator<SM, ID, RD> {

    private static final Logger LOG = Logger.getLogger(BaseJAXBTranslator.class);

    /** Whether or not to log initiation and response messages. */
    protected boolean logMessages = false;

    /** If logging the messages, use this logging level. */
    protected Level messagesLoggingLevel = Level.DEBUG;

    /** If logging the messages, use pretty-printed XML or not. */
    protected boolean prettyPrintXML = false;

    /** Whether or not to capture raw messages. */
    protected boolean captureMessages = false;

    /** Cache of raw messages */
    protected MessageCache messageCache;

    /** The {@link JAXBMarshallerFactory}. */
    protected JAXBMarshallerFactory marshallerFactory;

    /** The {@link ProtocolHelper}. */
    protected ProtocolHelper<SM, ID, RD> protocolHelper;

    /** The {@link StatisticsBean} instance used to report performance data. */
    protected StatisticsBean statisticsBean;

    /**
     * Create an instance of the translator without initializing its properties; this is intended
     * for Spring or other dependency-injection usage.
     * @throws ConfigurationException if there is an error
     */
    public BaseJAXBTranslator() throws ConfigurationException {
        // Do nothing
    }

    public JAXBMarshallerFactory getMarshallerFactory() {
        return marshallerFactory;
    }

    public void setMarshallerFactory(final JAXBMarshallerFactory marshallerFactory) {
        this.marshallerFactory = marshallerFactory;
    }

    public StatisticsBean getStatisticsBean() {
        return statisticsBean;
    }

    public void setStatisticsBean(final StatisticsBean statisticsBean) {
        this.statisticsBean = statisticsBean;
    }

    public boolean getLogMessages() {
        return logMessages;
    }

    public void setLogMessages(final boolean logMessages) {
        this.logMessages = logMessages;
    }

    public Level getMessagesLoggingLevel() {
        return messagesLoggingLevel;
    }

    public void setMessagesLoggingLevel(final Level messagesLoggingLevel) {
        this.messagesLoggingLevel = messagesLoggingLevel;
    }

    public boolean getPrettyPrintXML() {
        return prettyPrintXML;
    }

    public void setPrettyPrintXML(final boolean prettyPrintXML) {
        this.prettyPrintXML = prettyPrintXML;
    }

    public boolean getCaptureMessages() {
        return captureMessages;
    }

    public void setCaptureMessages(final boolean captureMessages) {
        this.captureMessages = captureMessages;
    }

    public MessageCache getMessageCache() {
        return messageCache;
    }

    public void setMessageCache(final MessageCache messageCache) {
        this.messageCache = messageCache;
    }

    @Override
    public SM createMessage(final ServiceContext<SM, ID, RD> serviceContext, final InputStream inputStream)
        throws ConfigurationException, ServiceException, ToolkitInternalException, ValidationException {
        final InputStream inputStreamToUse = doLoggingAndCaching(inputStream);
        final long initUnmarshalStartTime = System.currentTimeMillis();
        final JAXBM initiationMsg = createServiceMessage(serviceContext, inputStreamToUse);
        final long initUnmarshalEndTime = System.currentTimeMillis();
        final String msgName = JAXBHelper.getMessageName(initiationMsg);
        statisticsBean.record(StatisticsBean.Step.UNMARSHAL_MESSAGE, initUnmarshalStartTime, initUnmarshalEndTime, msgName);
        final long initTranslateStartTime = System.currentTimeMillis();
        final SM svcMessage = mapMessage(initiationMsg);
        final long initTranslateEndTime = System.currentTimeMillis();
        serviceContext.validateAfterUnmarshalling(svcMessage);
        statisticsBean.record(StatisticsBean.Step.CREATE_DATA, initTranslateStartTime, initTranslateEndTime, msgName);
        return svcMessage;
    }

    @Override
    public ID createInitiationData(final ServiceContext<SM, ID, RD> serviceContext, final InputStream inputStream)
        throws ConfigurationException, ServiceException, ToolkitInternalException, ValidationException {
        final InputStream inputStreamToUse = doLoggingAndCaching(inputStream);
        final long initUnmarshalStartTime = System.currentTimeMillis();
        final JAXBM initiationMsg = createServiceMessage(serviceContext, inputStreamToUse);
        final long initUnmarshalEndTime = System.currentTimeMillis();
        final String msgName = JAXBHelper.getMessageName(initiationMsg);
        statisticsBean.record(StatisticsBean.Step.UNMARSHAL_MESSAGE, initUnmarshalStartTime, initUnmarshalEndTime, msgName);
        final long initTranslateStartTime = System.currentTimeMillis();
        final SM svcMessage = mapMessage(initiationMsg);
        final long initTranslateEndTime = System.currentTimeMillis();
        serviceContext.validateAfterUnmarshalling(svcMessage);
        final ID initiationData = protocolHelper.getInitiationData(svcMessage);
        statisticsBean.record(StatisticsBean.Step.CREATE_DATA, initTranslateStartTime, initTranslateEndTime, msgName);
        return initiationData;
    }

    @Override
    public RD createResponseData(final ServiceContext<SM, ID, RD> serviceContext, final InputStream inputStream)
        throws ConfigurationException, ServiceException, ToolkitInternalException, ValidationException {
        final InputStream inputStreamToUse = doLoggingAndCaching(inputStream);
        final long respUnmarshalStartTime = System.currentTimeMillis();
        final JAXBM responseMsg = createServiceMessage(serviceContext, inputStreamToUse);
        final long respUnmarshalEndTime = System.currentTimeMillis();
        final String msgName = JAXBHelper.getMessageName(responseMsg);
        statisticsBean.record(StatisticsBean.Step.UNMARSHAL_MESSAGE, respUnmarshalStartTime, respUnmarshalEndTime, msgName);
        final long respTranslateStartTime = System.currentTimeMillis();
        final SM svcMessage = mapMessage(responseMsg);
        final long respTranslateEndTime = System.currentTimeMillis();
        serviceContext.validateAfterUnmarshalling(svcMessage);
        final RD responseData = protocolHelper.getResponseData(svcMessage);
        statisticsBean.record(StatisticsBean.Step.CREATE_DATA, respTranslateStartTime, respTranslateEndTime, msgName);
        return responseData;
    }

    @Override
    public ByteArrayInputStream createMessageStream(final ServiceContext<SM, ID, RD> serviceContext, final SM serviceMessage)
        throws ServiceException, ValidationException, ToolkitInternalException {
        final String msgName = getProtocolHelper().getMessageName(serviceMessage);
        serviceContext.validateBeforeMarshalling(serviceMessage);
        final long initTranslateStartTime = System.currentTimeMillis();
        final JAXBM jaxbMessage = mapMessage(serviceMessage);
        final long initTranslateEndTime = System.currentTimeMillis();
        statisticsBean.record(StatisticsBean.Step.CREATE_MESSAGE, initTranslateStartTime, initTranslateEndTime, msgName);
        final long initMarshalStartTime = System.currentTimeMillis();
        final ByteArrayInputStream initMsgStream = createMsgStream(serviceContext, jaxbMessage);
        final long initMarshalEndTime = System.currentTimeMillis();
        statisticsBean.record(StatisticsBean.Step.MARSHAL_MESSAGE, initMarshalStartTime, initMarshalEndTime, msgName);
        final ByteArrayInputStream inputStreamToReturn = doLoggingAndCaching(initMsgStream);
        return inputStreamToReturn;
    }

    @Override
    public ByteArrayInputStream createInitiationMessageStream(final ServiceContext<SM, ID, RD> serviceContext, final ID initiationData)
        throws ServiceException, ValidationException, ToolkitInternalException {
        final String msgName = initiationData.getMessageName();
        final SM svcMessage = getProtocolHelper().createServiceMessage(initiationData);
        serviceContext.validateBeforeMarshalling(svcMessage);
        final long initTranslateStartTime = System.currentTimeMillis();
        final JAXBM jaxbMessage = mapMessage(svcMessage);
        final long initTranslateEndTime = System.currentTimeMillis();
        statisticsBean.record(StatisticsBean.Step.CREATE_MESSAGE, initTranslateStartTime, initTranslateEndTime, msgName);
        final long initMarshalStartTime = System.currentTimeMillis();
        final ByteArrayInputStream initMsgStream = createMsgStream(serviceContext, jaxbMessage);
        final long initMarshalEndTime = System.currentTimeMillis();
        statisticsBean.record(StatisticsBean.Step.MARSHAL_MESSAGE, initMarshalStartTime, initMarshalEndTime, msgName);
        final ByteArrayInputStream inputStreamToReturn = doLoggingAndCaching(initMsgStream);
        return inputStreamToReturn;
    }

    @Override
    public ByteArrayInputStream createResponseMessageStream(final ServiceContext<SM, ID, RD> serviceContext, final RD responseData)
        throws ServiceException, ValidationException, ToolkitInternalException {
        final String msgName = responseData.getMessageName();
        final SM svcPMessage = getProtocolHelper().createServiceMessage(responseData);
        serviceContext.validateBeforeMarshalling(svcPMessage);
        final long respTranslateStartTime = System.currentTimeMillis();
        final JAXBM jaxbMessage = mapMessage(svcPMessage);
        final long respTranslateEndTime = System.currentTimeMillis();
        statisticsBean.record(StatisticsBean.Step.CREATE_MESSAGE, respTranslateStartTime, respTranslateEndTime, msgName);
        final long respMarshalStartTime = System.currentTimeMillis();
        final ByteArrayInputStream respMsgStream = createMsgStream(serviceContext, jaxbMessage);
        final long respMarshalEndTime = System.currentTimeMillis();
        statisticsBean.record(StatisticsBean.Step.MARSHAL_MESSAGE, respMarshalStartTime, respMarshalEndTime, msgName);
        final ByteArrayInputStream respStreamToReturn = doLoggingAndCaching(respMsgStream);
        return respStreamToReturn;
    }

    /**
     * Create the {@link ByteArrayInputStream} containing the marshalled message.
     * @param serviceContext the {@link ServiceContext}
     * @param jaxbMessage the JAXB-generated object representing the message
     * @return the stream
     * @throws ServiceException if a JAXBException or ToolkitException occurs
     */
    protected ByteArrayInputStream createMsgStream(final ServiceContext<SM, ID, RD> serviceContext, final JAXBM jaxbMessage) throws ServiceException {
        try {
            final Marshaller marshaller = marshallerFactory.getMarshaller(serviceContext);
            final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(0);
            marshaller.marshal(jaxbMessage, byteArrayOutputStream);
            final byte[] bytes = byteArrayOutputStream.toByteArray();
            final ByteArrayInputStream resultStream = new ByteArrayInputStream(bytes);
            return resultStream;
        } catch (ToolkitException | JAXBException e) {
            throw new ServiceException("Exception marshalling the message.", e);
        }
    }

    /**
     * Create the JAXB-generated object that represents the message
     * @param serviceContext the {@link ServiceContext}
     * @param inputStream the stream
     * @return the message
     * @throws ConfigurationException if the message cannot be umarshelled due to Toolkit configuration
     * @throws ServiceException if there is a JAXB or SAX exception
     */
    protected JAXBM createServiceMessage(final ServiceContext<SM, ID, RD> serviceContext, final InputStream inputStream) throws ConfigurationException, ServiceException {
        try {
            final Unmarshaller unmarshaller = marshallerFactory.getUnmarshaller(serviceContext);
            if (serviceContext instanceof XMLServiceContext && ((XMLServiceContext) serviceContext).addDefaultNamespace()) {
                final XMLReader reader = getXMLReader();
                final NamespaceFilter inFilter = new NamespaceFilter(((XMLServiceContext) serviceContext).getDefaultNamespace(), true);
                inFilter.setParent(reader);
                final SAXSource saxSource = new SAXSource(inFilter, new InputSource(inputStream));
                return (JAXBM) unmarshaller.unmarshal(saxSource);
            } else {
                Map<String, Boolean> parserFeatures = null;
                if (serviceContext instanceof XMLServiceContext) {
                    parserFeatures = ((XMLServiceContext) serviceContext).getParserFeatures();
                }
                if (parserFeatures != null && !parserFeatures.isEmpty()) {
                    final SAXParserFactory parserFactory = SAXParserFactory.newInstance();
                    final List<String> schemaUrls = ((XMLServiceContext) serviceContext).getSchemaURLs();
                    parserFactory.setSchema(marshallerFactory.getSchema(schemaUrls));
                    try {
                        for (final Map.Entry<String, Boolean> entry : parserFeatures.entrySet()) {
                            LOG.debug("Setting feature " + entry.getKey() + " to " + entry.getValue());
                            parserFactory.setFeature(entry.getKey(), entry.getValue());
                        }
                        final SAXParser saxParser = parserFactory.newSAXParser();
                        saxParser.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, "");
                        saxParser.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, "");
                        final XMLReader xmlReader = saxParser.getXMLReader();
                        final UnmarshallerHandler uh = unmarshaller.getUnmarshallerHandler();
                        xmlReader.setContentHandler(uh);
                        xmlReader.parse(new InputSource(inputStream));
                        return (JAXBM) uh.getResult();
                    } catch (IOException | ParserConfigurationException e) {
                        throw new ServiceException("Exception creating message object from InputStream.", e);
                    }
                } else {
                    return (JAXBM) unmarshaller.unmarshal(inputStream);
                }
            }
        } catch (JAXBException | ParserConfigurationException | SAXException e) {
            throw new ServiceException("Exception creating message object from InputStream.", e);
        }
    }

    private <S extends InputStream> S  doLoggingAndCaching(final S inputStream) throws ServiceException {
        final S inputStreamAfterLogging;
        if (logMessages) {
            inputStreamAfterLogging = LoggingHelper.copyAndLogStream(LOG, messagesLoggingLevel, prettyPrintXML, inputStream);
        } else {
            inputStreamAfterLogging = inputStream;
        }

        final S inputStreamAfterCapture;
        if (captureMessages) {
            final byte[] byteArray = toByteArray(inputStreamAfterLogging);
            final String messageString = new String(byteArray, StandardCharsets.UTF_8);
            messageCache.add(messageString);
            return (S) (new ByteArrayInputStream(byteArray));
        } else {
            inputStreamAfterCapture = inputStreamAfterLogging;
        }
        return inputStreamAfterCapture;
    }

    /**
     * Construct an XMLReader.
     * @return the reader
     * @throws ParserConfigurationException
     * @throws SAXException
     */
    private static XMLReader getXMLReader() throws ParserConfigurationException, SAXException {
        final SAXParserFactory parserFactory = SAXParserFactory.newInstance();
        final SAXParser parser = parserFactory.newSAXParser();
        parser.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, "");
        parser.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, "");
        final XMLReader reader = parser.getXMLReader();
        return reader;
    }

    /**
     * Map the {@link ServiceMessage} to the appropriate JAXB-generated object.
     * @param svcMsg the {@link ServiceMessage}
     * @return the JAXB-generated object representing the message
     */
    protected abstract JAXBM mapMessage(SM svcMsg);

    /**
     * Map the JAXB-generated object representing a message to the appropriate {@link ServiceMessage}.
     * @param svcMsg the JAXB-generated object
     * @return the {@link ServiceMessage}
     */
    protected abstract SM mapMessage(JAXBM svcMsg);

    public ProtocolHelper<SM, ID, RD> getProtocolHelper() {
        return protocolHelper;
    }

    public void setProtocolHelper(final ProtocolHelper<SM, ID, RD> protocolHelper) {
        this.protocolHelper = protocolHelper;
    }
}
