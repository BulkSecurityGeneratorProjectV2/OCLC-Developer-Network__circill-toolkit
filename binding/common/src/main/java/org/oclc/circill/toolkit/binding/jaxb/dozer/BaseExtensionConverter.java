/*
 * Copyright (c) 2011 eXtensible Catalog Organization.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the MIT/X11 license. The text of the license can be
 * found at http://www.opensource.org/licenses/mit-license.php.
 */

package org.oclc.circill.toolkit.binding.jaxb.dozer;

import org.oclc.circill.toolkit.binding.jaxb.JAXBHelper;

import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.List;

import org.dozer.DozerConverter;
import org.dozer.Mapper;
import org.dozer.MapperAware;
import org.dozer.MappingException;

/**
 * Converts an object found in an Ext element.
 * Every binding implementation should create one class that specializes
 * this generic class on its JAXB-generated class which implements the Ext element. For example in the
 * <code>org.oclc.circill.toolkit.binding.ncipv2_01.jaxb.dozer</code> package:
 *<pre>{@code public class NCIPv2_01ExtensionConverter extends BaseExtensionConverter<Ext> {

public NCIPv2_01ExtensionConverter() {

super(Ext.class);

}
}}</pre>
 * It requires a {@code custom-converter-param} that names
 * the two classes that it converts between. The two class names are separated by a comma; the first is the full class
 * name of the class from the org.oclc.circill.toolkit.service.&lt;protocol&gt; package and the second is the full class
 * name of the class generated by the JAXB schema compiler. If the schema elements to which the classes correspond are
 * repeatable, the class name is enclosed in {@code List&lt;} and {@code >&gt;}.
 *
 * An example of the Dozer mapping file configuration for a non-repeatable element is:
 *<pre>{@code
 * <field custom-converter="org.oclc.circill.toolkit.binding.wclv1_0.jaxb.dozer.WCLv1_0ExtensionConverter"
 *    custom-converter-param="org.oclc.circill.toolkit.service.ncip.UserFiscalAccountSummary,org.oclc.circill.toolkit.binding.wclv1_0.jaxb.elements.UserFiscalAccountSummary">
 *    <a>userFiscalAccountSummary</a>
 *    <b>ext</b>
 *</field>}</pre>
 * And an example of the Dozer mapping file configuration for a repeatable element is:
 *<pre>{@code
 * <field custom-converter="org.oclc.circill.toolkit.binding.wclv1_0.jaxb.dozer.WCLv1_0ExtensionConverter"
 *    custom-converter-param="List&lt;org.oclc.circill.toolkit.service.ncip.ResponseElementControl&gt;,List&lt;org.oclc.circill.toolkit.binding.wclv1_0.jaxb.elements
 *    .ResponseElementControl&gt;">
 *    <a>responseElementControls</a>
 *    <b>ext</b>
 *</field>}</pre>
 *
 *
 * @param <EXT> the JAXB-generated class that represents the extension, e.g. Ext.
 */
public class BaseExtensionConverter<EXT> extends DozerConverter<Object, EXT> implements MapperAware {

    protected Mapper mapper;

    protected Class<?> aClass;
    protected boolean aIsList = false;

    protected Class<?> bClass;
    protected boolean bIsList = false;

    protected final Class<EXT> jaxbExtClass;

    public BaseExtensionConverter(final Class<EXT> jaxbExtClass) {
        super(Object.class, jaxbExtClass);
        this.jaxbExtClass = jaxbExtClass;
    }

    protected synchronized void lazyInit() {
        if (aClass == null || bClass == null) {
            final String parameter = getParameter();
            final String[] parameters = parameter.split(",");
            if (parameters.length == 2) {
                String aParam = parameters[0];
                if (aParam.matches("^List<.*>$")) {
                    aIsList = true;
                    aParam = aParam.substring(5, aParam.length() - 1);
                }
                try {
                    aClass = Class.forName(aParam);
                } catch (ClassNotFoundException e) {
                    throw new MappingException("Could not find class \"" + aParam + "\".", e);
                }
                String bParam = parameters[1];
                if (bParam.matches("^List<.*>$")) {
                    bIsList = true;
                    bParam = bParam.substring(5, bParam.length() - 1);
                }
                try {
                    bClass = Class.forName(bParam);
                } catch (ClassNotFoundException e) {
                    throw new MappingException("Could not find class \"" + bParam + "\".", e);
                }
            } else {
                throw new MappingException("Parameter must be in the format \"a-class,b-class\", not \"" + parameter + "\".");
            }
        }
    }

    @Override
    @SuppressWarnings({"checkstyle:FinalParameters", "checkstyle:ParameterAssignment"}) // Dozer converters assume the target object is modified
    public EXT convertTo(final Object source, EXT destination) {
        lazyInit();
        if (destination == null) {
            try {
                destination = jaxbExtClass.getConstructor().newInstance();
            } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) {
                throw new MappingException(e);
            }
        }

        if (List.class.isAssignableFrom(source.getClass())) {
            final List<Object> sourceList = (List) source;
            for (final Object srcObj : sourceList) {
                final Object innerObj = doConvert(srcObj, bClass);
                JAXBHelper.addToExtension(destination, innerObj);
            }
        } else {
            final Object innerObj = doConvert(source, bClass);
            JAXBHelper.addToExtension(destination, innerObj);
        }
        return destination;
    }

    @Override
    public Object convertFrom(final EXT source, final Object destination) {
        Object result = destination;
        lazyInit();
        if (source != null) {
            for (final Object obj : JAXBHelper.getAnyList(source)) {
                if (bClass.isAssignableFrom(obj.getClass())) {
                    final Object svcObj = doConvert(obj, aClass);
                    if (aIsList) {
                        if (result == null) {
                            result = new ArrayList<>();
                        }
                        ((List) result).add(svcObj);
                    } else {
                        result = svcObj;
                    }
                }
            }
        }
        return result;
    }

    protected Object doConvert(final Object source, final Class<?> clazz) {
        Object obj = null;
        if (source != null) {
            obj = mapper.map(source, clazz);
        }
        return obj;
    }

    @Override
    public void setMapper(final Mapper mapper) {
        this.mapper = mapper;
    }

}
